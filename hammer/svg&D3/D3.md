# Basic
- D3 employs a declarative approach, operating on arbitrary sets of nodes called - selections

    ```js
    d3.selectAll("p").style("color", "white")
    d3.select("body").style("background-color", "black")
    ```
  - Modifying documents using the W3C DOM API is tedious: the method names are verbose, and the imperative approach requires manual iteration and bookkeeping of temporary state

    ```js
    var paragraphs = document.getElementsByTagName("p");
    for (var i = 0; i < paragraphs.length; i++) {
        var paragraph = paragraphs.item(i);
        paragraph.style.setProperty("color", "white", null);
    }
    ```

- Direct access to the underlying DOM is also possible, as each D3 selection is simply an array of nodes
- Styles, attributes, and other properties can be specified as functions of data in D3, not just simple constants
  - D3 provides many built-in reusable functions and function factories, such as graphical primitives for area, line and pie charts
    - Computed properties often refer to bound data. Data is specified as an array of values, and each value is passed as the first argument (`d`) to selection functions. With the default join-by-index, the first element in the data array is passed to the first node in the selection, the second element to the second node, and so on

    ```js
    d3.selectAll("p")
        .data([4, 8, 15, 16, 23, 42])
            .style("font-size", function(d) { return d + "px"; })
    ```

    - Once the data has been bound to the document, you can omit the data operator; D3 will retrieve the previously-bound data. This allows you to recompute properties without rebinding
## Enter and Exit
- Create new nodes for incoming data and remove outgoing nodes that are no longer needed
- When data is bound to a selection, each element in the data array is paired with the corresponding node in the selection. If there are fewer nodes than data, the extra data elements form the enter selection, which you can instantiate by appending to the enter selection

    ```js
    // Update…
    var p = d3.select("body")
        .selectAll("p")
        .data([4, 8, 15, 16, 23, 42])
            .text(function(d) { return d; })

    // Enter…
    p.enter().append("p")
        .text(function(d) { return d; })

    // Exit…
    p.exit().remove()
    ```

## Transitions
- Transitions gradually interpolate styles and attributes over time
- Tweening can be controlled via easing functions such as “elastic”, “cubic-in-out” and “linear”
- D3’s interpolators support both primitives, such as numbers and numbers embedded within strings (font sizes, path data, etc.), and compound values. You can even extend D3’s interpolator registry to support complex properties and data structures
# D3-force
- > https://github.com/d3/d3-force#forces
- To remove the force with the given name, pass null as the force
- A force is simply a function that modifies nodes’ **positions** or **velocities**
  - In this context, a force can apply a classical physical force such as electrical charge or gravity, or it can resolve a geometric constraint, such as keeping nodes within a bounding box or keeping linked nodes a fixed distance apart
- Centering
  - This force helps keeps nodes in the center of the viewport, and unlike the positioning force, it does not distort their relative positions
- Collision
  - The collision force treats nodes as circles with a given **radius**, rather than points, and prevents nodes from overlapping
- Links
  - The link force pushes linked nodes together or apart according to the desired link distance
- Many-body
  - The many-body (or n-body) force applies mutually amongst **all nodes**
  - It can be used to simulate gravity (attraction) if the strength is positive, or electrostatic charge (repulsion) if the strength is negative
  - A positive value causes nodes to attract each other, similar to gravity, while a negative value causes nodes to repel each other, similar to electrostatic charge