# 基本
- Go 文件名由小写字母组成，使用下划线 `_` 分隔
- `_`
    - 空白标识符
    - 可用于变量声明或赋值
        - 任何赋值给这个标识符的值都将被抛弃
    - 通常作为忽略占位符
    - 空标识符可用来临时规避编译器对未使用变量和导入包的错误检查
    - 它是预置成员，不能重新定义
- 多个语句写在一行必须使用 `;`
- Go 程序的一般结构
    1. `import`
    2. 常量、变量和类型的定义或声明
    3. 若存在 `init` 函数的话，则对该函数进行定义
        - 这是一个特殊的函数，每个含有该函数的包都会首先执行这个函数
    4. 若当前包是 `main` 包，则定义 `main` 函数
    5. 定义其他的函数：首先是类型的方法；接着是按照 `main` 函数中调用的先后顺序来定义相关函数（若有很多函数，可以按照字母顺序来进行排序）
- [ ] Go 程序的执行（程序启动）顺序如下：
    1. 按顺序导入所有被 `main` 包引用的其它包，然后在每个包中执行如下流程：
    2. 如果该包又导入了其它的包，则从第一步开始递归执行，但是每个包只会被导入一次
    3. 然后以相反的顺序在每个包中初始化常量和变量，如果该包含有 `init` 函数的话，则调用该函数
    4. 在完成这一切之后，`main` 也执行同样的过程，最后调用 `main` 函数开始执行程序
- 返回某个对象的函数或方法的名称一般都是使用名词，没有 `Get...` 之类的字符；如果是用于修改某个对象，则使用 `SetName`；有必须要的话可以使用大小写混合的方式，如 `MixedCaps` 或 `mixedCaps`，而不是使用下划线来分割多个单词
- 常量使用关键字 `const` 定义，用于存储不会改变的数据
- 常量的值必须是能够在编译时就能够确定的
    - 编译期间自定义函数均属于未知，因此无法用于常量的赋值，但可以使用内置函数，如 `len()`
- 数字型的常量是没有大小和符号的，并且可以使用任何精度而不会导致溢出
- 反斜杠 `\` 可以在常量表达式中作为多行的连接符使用
# 包
- 每个程序都由包的概念组成，可以使用自身的包或者从其它包中导入内容
    - 导入包即等同于包含了这个包的所有的代码对象
- 所有的包名都应该使用小写字母
- 每个 go 文件都属于且仅属于一个包，一个包可以由许多以 `.go` 为扩展名的源文件组成
- 一个应用程序可以包含不同的包，而且即使你只使用 `main` 包也不必把所有的代码都写在一个巨大的文件里：可以用一些较小的文件，并且在每个文件非注释的第一行都使用 `package main` 来指明这些文件都属于 `main` 包。如果你打算编译包名不是为 `main` 的源文件，如 `pack1`，编译后产生的对象文件将会是 `pack1.a` 而不是可执行程序
- 属于同一个包的源文件必须全部被一起编译，一个包即是编译时的一个单元，因此根据惯例，每个目录都只包含一个包
- 如果对一个包进行更改或重新编译，所有引用了这个包的客户端程序都必须全部重新编译
- 每一段代码只会被编译一次
- 导入多个包时，最好按照字母顺序排列包名，这样做更加清晰易读
- 如果包名不是以 `.` 或 `/` 开头，如 `"fmt"` 或者 `"container/list"`，则 Go 会在全局文件进行查找；如果包名以 `./` 开头，则 Go 会在相对目录中查找；如果包名以 `/` 开头，则会在系统的绝对路径中查找
- Go 中的包模型采用了显式依赖关系的机制来达到快速编译的目的，编译器会从后缀名为 `.o` 的对象文件（需要且只需要这个文件）中提取传递依赖类型的信息
    - 如果 A.go 依赖 B.go，而 B.go 又依赖 C.go：
        - 编译 C.go, B.go, 然后是 A.go
        - 为了编译 A.go, 编译器读取的是 B.o 而不是 C.o
- 可见性规则
- 除了符号 `_`，包中所有代码对象的标识符必须是唯一的，以避免名称冲突。但是相同的标识符可以在不同的包中使用，因为可以使用包名来区分它们
- 当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如 `Group1`，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 `public`）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 `private`）
- 使用别名 `import fm "fmt"` 
    - 可以解决同名冲突问题
# 函数
- 函数语法

    ```go
    func functionName(param1 type1, param2 type2, …) (t1 type1, t2 type2) {}
    ```

    - 左大括号 `{` 必须与函数声明放在同一行
    - 右大括号 `}` 放在紧接着函数体的下一行
        - 若函数非常简短，也可放在同一行
    - 可以在括号第一个 `()` 中写入 0 个或多个参数（使用逗号 `,` 分隔），每个参数的名称后面须跟着该参数的类型
    - 第二个括号写返回值
- go 编译器会在一行语句的结束自动加分号
- `main` 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 `init()` 函数则会先执行该函数）
- 在程序开始执行并完成初始化后，第一个调用（程序的入口点）的函数是 `main.main()`，该函数一旦返回就表示程序已成功执行并立即退出
- 若 `main` 包的源代码没有包含 `main` 函数，则会引发构建错误 `undefined: main.main` 
- `main` 函数既没有参数，也没有返回值
- 只有当某个函数需要被外部包调用的时候才使用大写字母开头，并遵循 Pascal 命名法；否则就遵循骆驼命名法，即第一个单词的首字母小写，其余单词的首字母大写
- 单纯地打印一个字符串或变量可以使用预定义的方法来实现，如：`print`、`println`
    - 这些函数只可以用于调试阶段，在部署程序的时候务必将它们替换成 `fmt` 中的相关函数
- 当被调用函数的代码执行到结束符 `}` 或返回语句时就会返回，然后程序继续执行调用该函数之后的代码。
- 程序正常退出的代码为 0，即 `Program exited with code 0`
# 注释
- 每一个包应该有相关注释，在 `package` 语句之前的块注释将被默认认为是这个包的文档说明，其中应该提供一些相关信息并对整体功能做简要的介绍
- 一个包可以分散在多个文件中，但是只需要在其中一个进行注释说明即可
    - 当开发人员需要了解包的一些情况时，自然会用 `godoc` 来显示包的文档说明
    - 在首行的简要注释之后可以用成段的注释来进行更详细的说明，而不必拥挤在一起
    - 在多段注释之间应以空行分隔加以区分
- 几乎所有全局作用域的类型、常量、变量、函数和被导出的对象都应该有一个合理的注释
    - 如果这种注释（称为文档注释）出现在函数前面，例如函数 `Abcd`，则要以 `"Abcd..."` 作为开头
# 类型
- 类型定义了某个变量的值的集合与可对其进行操作的集合
- 使用 `var` 声明的变量且未初始化的变量的值会自动初始化为该类型的零值
- 基本类型
    - `int`、`float`、`bool`、`string`
- 结构化的类型
    - `struct`、`array`、`slice`、`map`、`channel`
- 只描述类型的行为的类型
    - `interface`
- 结构化的类型没有真正的值，它使用 `nil` 作为默认值
- Go 语言中不存在类型继承
- 使用 `type` 关键字可以自定义类型，如一个结构体，或是一个已经存在的类型的别名

    ```go
    type IZ int
    var a IZ = 5
    ```

    - 这里并不是真正意义上的别名，因为使用这种方法定义之后的类型可以拥有更多的特性，且在类型转换时仍须显式转换
- 每个值都必须在经过编译后属于某个类型（编译器必须能够推断出所有值的类型），因为 Go 语言是一种静态类型语言
- Go 语言不存在隐式类型转换，所有的转换都必须显式说明，就像调用一个函数一样（类型在这里的作用可以看作是一种函数）