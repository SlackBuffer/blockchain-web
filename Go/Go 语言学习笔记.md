# 简介
- go 文件头部用 package 声明所属包名称
- 语句结束分号会被默认省略，支持 C 样式注释
- 入口函数 `main` 没有参数，且必须放在 `main` 包中
- 用 `import` 语句导入标准库或第三方包
    - 未使用的导入会被编译器当成是错误
- 函数
    - 可定义多个返回值
    - 第一个括号是参数名和类型
    - 第二个括号写的是返回值的类型
    - 函数可作为参数或返回值
    - 用 `defer` 定义延迟调用，无论函数是否出错，它都确保结束前被调用
        - 常用来释放资源、解除锁定、执行清理操作
        - 可定义多个 defer，按 FILO 顺序执行
- 数据
    - 切片实现动态数组功能
    - 将字典（`map`）类型内置，直接从运行时层面获得性能优化
        - > ok-idiom 模式：在多返回值中用一个名为 ok 的布尔值来标示操作是否成功
    - 结构体（`struct`）可匿名嵌入其他类型
- 方法
    - 可以为当前包的任意类型定义方法
    - 可以通过直接调用匿名字段的方式实现与继承类似的功能
- 接口
    - duck type，无须在实现类型上添加显式声明
    - 空接口类型 `interface()`（用途类似 OOP 里的 system.Object），可接收任意类型对象
- 并发
    - 整个运行时完全并发化设计，凡是看到的几乎都在以 goroutine 方式运行
    - channel 与 goroutine 搭配，实现用通信代替内存共享的 CSP 模型
# 类型
## 变量
### 定义
- 基础数据类型划分明确
- `var` 定义变量，支持**类型推断**（`var y = false`）
- 编译器确保变量总是被初始化为 0
- 可一次定义、初始化多个不同类型的多个变量（`var x, y int`）
- 建议以组的方式整理多行变量定义

    ```go
    var (
        x, y int
        a, s = 100, "abc"
    )
    ```
    
- 编译器将未使用的**局部变量**当做错误，全局变量没事
- 单引号一个字符，双引号字符串；一个字符加`""` 才能正常打印出该字符
- 简短模式 short variable declaration（`x := 100`）
    - 只能用在函数内部
    - 不能提供数据类型
    - 定义变量的同时要显式初始化
    - > 用在函数多返回值，`if/for/switch` 语句中定义局部变量很方便
### 简短模式
- 简短模式不总是重新定义变量，可能是部分退化的赋值操作

    ```go
    func main() {
        x := 100
        println(&x)
        x, y := 200, "abc"  // x 为退化赋值，y 是变量定义
        println(&x, x)
    }
    ```

- 退化赋值条件
    1. 至少有一个新变量被定义
    2. 必须是同一作用域
- 处理函数错误返回值时，利用退化赋值可以重用 `err` 变量
### 多变量赋值
- 赋值操作必须保证左右值类型相同
- 首先计算出所有右值，再按对应的顺序给左侧变量赋值
## 命名
- 首字母大小写决定变量作用域
    - 首字母大写的为导出成员，可被包外引用
    - 小写的仅能在包内使用



- `&` 取地址