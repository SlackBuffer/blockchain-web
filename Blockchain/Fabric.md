# Terminology
- OBC：open blockchanin
- 共识 consensus
    - 用于生成一个关于排序的协定；确认构成区块的交易集的正确性
    - 贯穿整个交易流程的广义术语
- 链码 chaincode
    - 一个运行在账本上的软件，负责 encode **资产**以及对资产进行修改的**交易指令**
- 安装 install
    - 将 chaincode 放到节点的文件系统的过程（即将 ChaincodeDeploymentSpec 信息存到 chaincodeInstallPath-chaincodeName.chainVersion 文件中）
- 初始化 initialize
    - 初始化 chaincode application 的方法
- 成员 member
    - 拥有网络的唯一根证书的合法的独立实体
    - 像 peer 节点和 application clients 这样的网络组件会连接到一个成员
- MSP membership service provider
    - 指为 clients、节点提供资格证书使他们可以参与 Fabric 网络的一个系统的抽象组件
    - client 用证书认证他们的交易，节点用证书认证交易处理结果（背书）
    - 尽管此接口和系统的交易处理组件密切关联，它旨在实现（ While strongly connected to the transaction processing components of the systems, this interface aims to have membership services components defined, in such a way that alternate implementations of this can be smoothly plugged in without modifying the core of transaction processing components of the system）
- Fabric-ca
    - Fabric-ca 是默认的证书授权组件，向网络成员组织和它们的用户颁发基于 PKI 的证书
    - ca 为每个成员颁发一个根证书（rootCert），为每个授权用户颁发一个注册证书（eCert），为每个注册证书本法大量交易证书（tCerts）
    - eCert 是长期的身份凭证；tCerts 是短期的身份凭证，匿名且不可链接
- 成员服务 membership services
    - 成员服务在许可的区块链网络上认证、授权、管理身份
    - peer 和 orderer 上运行的成员服务代码都会认证、授权区块链操作
    - 是对 MSP 抽象的基于 PKI 的实现
        - Public Key Infrastructure 公钥体系
    - fabric-ca 组件是成员服务的一个实现，用于管理身份，in particular 它负责 eCert 和 tCert 的颁发的撤销
- 动态成员 dynamic membership
    - Fabric 支持增删成员、节点、排序服务节点而不影响到整个网络的可操作性
- 区块 block
    - 在一个通道上
    - 一组有序交易的合集
    - （cryptographically）经过加密后链接到先前的区块上
- 初始区块 genesis block
    - 是初始化一个区块链网络或通道的配置区块，也是链上的第一个区块
- 配置区块 configuration block
    - 包含定义系统链（ordering service）或通道的成员和策略所需的配置数据
    - 一个通道或整个网络的配置更改都会使得一个新的配置区块追加到适当的链上，此区块会包含初始区块的内容加上增量
- 通道 channel
    - Fabric 网络上私有的 blockchain overlay
    - 实现了数据的隔离和保密
    - 通道中的节点共享一个 channel-specific 的账本，交易方要想与账本交互必须先通过该通道的校验
    - 通道由一个配置块来定义
- 链 chain
    - 是交易日志
    - 以通过 hash 链接的区块的结构存在（structured as hash-linked blocks of transactions）
    - peer 从排序服务接收交易区块，根据背书策略和并发冲突区块上的交易是否有效，（若有效）则将该区块连接到 peer 的文件系统的 hash chain 上
- 系统链 system chain
    - 包含在系统层面定义网络的配置区块
    - 存在于排序服务当中，类似于通道，它具有初始配置，包含 MSP 信息、策略、配置的细节等信息
    - 整个网络发生的任意变化都会使得一个新的配置区块被加到系统链中
    - 系统链可以理解成一个或一组通道的 common binding
- 当前状态 current state（world state）
    - 表示链的交易日志中所有的键的最新值
    - 节点将处理过的区块中的每笔有效交易提交到账本的当前状态
- state dababase
    - 当前状态的数据储存在 stateDB 中，以便从 chaincode 中高效读写
    - levelDB，couchDB
- 查询 query    
    - 对当前状态中某个键的值的查询请求
- 提交 commitment
    - 通道中的每个节点验证交易的有序区块，然后将区块提交（writes-appends）到属于它的通道账本的副本上
    - 节点会将每个区块中的交易标记为有效或者无效
- 背书 endorsement
    - 指特定节点执行一个交易并返回 YES-NO 响应给生成该交易提案的 client application 的过程
    - chaincode applications 有相应的背书策略，指定了背书节点
- 策略 policy
    - 分背书策略，校验策略，区块提交策略，链码管理策略，网络通道管理管理策略
- 背书策略 endorsement policy
- 交易 transaction
    - 是一个 invoke 或 instantiate 操作
- 调用 invoke
    - 用于调用链码的函数
    - 调用被捕捉到后作交易提案（transaction proposal）处理，然后执行一个包括背书、ordering（共识）、验证、提交的模块化流程
    - invoke 的结构是一个函数和一个参数的数组
    - 是从账本读-写数据的请求
- 提案 proposal
    - 向一个通道上的特定节点发送的背书请求
    - proposal 要么是实例化请求，要么是 invoke（read-write）请求
- 实例化 instantiate
    - 启动链码容器的过程（在 lccc 中将 ChaincodeData 保存到 state 中，然后 deploy Chaincode 并执行 Init 方法）
- 账本 ledger
    - A ledger is **a channel’s chain** and **current state data** which is maintained by each peer on the channel
- 节点 Peer
    - 一个网络实体，负责维护 ledger、运行 chaincode 容器来对 ledger 进行读写操作
    - members 拥有并维护节点
- 锚节点 anchor peer 
    - 通道中能被所有其它节点检测到、并能与之进行通信的节点
    - 通道中的每个成员都有一个或多个锚节点，使从属于不同成员的节点可以发现通道上的所有节点
- 主导节点 leading peer
    - 每一个成员在其订阅的通道上可以拥有多个节点，其中的一个节点充当主导节点，代表该成员与网络排序服务通信
    - 排序服务将区块传递给主导节点，主导节点再将区块分发给同一个成员集群下的其它节点
- 排序（共识）服务 ordering service
    - 一个定义好的、负责将交易排序后放入区块的节点的集合
    - 独立于 peer processes 存在
    - 对于网络上所有通道而言，都按以先到先得的方式将交易排序
    - 设计 ordering service 是为了在拆箱即用的 SOLO 和 Kafaka 以外支持可插拔的实现
    - 排序服务是整个网络公用的 binding，包含与每个成员绑定的 cryptographic identity material
- 并发控制版本检查 concurrency control version check
    - 保持通道中个节点状态同步的途径
    - 节点并行执行交易，在提交到账本之前，节点会检查在执行期间读到的数据是否被更改
    - 若读取的数据在执行和提交之间被修改了，CCVC 就会检测到，交易会被标记为无效，数据不会更新到状态数据库
- Gossip 协议 gossip protocol
    - gossip 数据传输协议有三项功能：管理节点的 discovery 和通道成员；在通道的所有节点之间广播账本数据；同步通道上所有节点的账本状态
- SDK software development kit
    - Hyperledger Fabric client SDK 为开发人员提供了一个库的结构化环境，用于编写、测试链码应用程序
    - 通过一个标准接口实现了完全的可配置、可扩展
    - 包括签名的加密算法、日志框架、状态存储在内的组件可以轻易替换
    - The SDK API uses protocol buffers over gRPC for transaction processing, membership services, node traversal and event handling applications to communicate across the fabric
# 概览
- 成员管理 menbership
- 基于 P2P 的通信网络 gRPC，通过 HTTP 报文实现节点之间的消息传输
- 共识算法（PBFT,Raft,PoW,PoS）模块化，可插式
- 帐链代码 chaincode
    - 用于构成智能合约
    - 嵌在交易中，所有确认节点在确认交易时都必须执行它
    - 执行环境是一个“沙箱”（Docker）
- [ ] VP，NVP 节点
- [ ] BFT，CFT，XFT，PBFG
- [ ] gRPC
- 链
    - 链 􏰉= Peers + Ledger + Ordering Channel
    - 将参与者和数据（包含 chaincode）隔离
- 通道：提供一种通讯机制，将 peer 和 orderer 连接起来，形成一个个具有保密性的通讯链路（虚拟）
- Fabric 区块链默认包含一个账本（系统账本）和一个通道
- 子账本可以被创建，并绑定到一个通道
- 事务：chaincode 的一次调用
    - 事务类型：chaincode，configuration，custom
- 事务处理流程
    - 应用向一个或多个 peer 节点发送对事务的背书请求
    - 背书节点执行 chaincode，不将结果提交到本地账本，只将结果返回给应用
    - 应用收集所有背书节点的结果后，将结果广播给 orderers
    - orderers 执行共识过程，生成 block，通过消息通道批量地将 block 发布给 peer 节点
    - 各个 peer 节点验证交易，并提交到本地账本
# chaincode
- 是什么
    - 一个接口的实现代码
    - 与 Fabric 区块链交互的唯一渠道
    - 生成 transaction 的唯一来源
        - transactions -> blocks -> ledger
    - 智能合约在 Fabric 上的实现方式
    - 部署在 Fabric 区块链网络节点上
- SDK
    - $GOPATH/src/github.com/hyperledger/fabric/core/chaincode/shim
    - shim 包是供 Chaincode 开发的 SDK，理论上应该可以独⽴使用，但目前并非如此，它仍然依赖于 Fabric 某些其它模块
- Fabric 节点运行模式
    - 一般模式
        - chaincode 运行在 docker 容器中
        - 开发调试过程繁杂：部署 -> 调试 -> 修改 -> 创建 docker 镜像 -> 部署
    - 开发模式
        - chaincode 运行在本地
        - 开发调试相对容易：部署 -> 调试 -> 修改 -> 部署
- transaction：一次 chaincode 函数的运行
    - 存储 chaincode 执行相关的信息，如 chaincodeID，函数名称，参数，并不包含操作的数据
- world state：Fabric 区块链系统中所有变量值得集合
    - transaction 实际操作的是数据，每个 chaincode 都有自己的数据
    - Fabric 使用 Rocksdb（key-value 数据库)存储数据
    - 每一对 key-value 称为一个 state，所有 chaincode 的 state 的合集就是 world state
## channel
- channel：通道，子链
    - 同一 peer 可加入不同 channel
    - chaincode 的操作基于 channel 进行
    - 同一 channel 上的 peer 节点同步其上 chaincode 执行的结果
- endorser
    - （模拟）执行 chaincode
    - 分离计算任务，减轻 consensus 节点负担，增加吞吐量
    - 支持 endorsement policy，更加灵活
- orderer
    - 对 chaincode 执行结果 consensus
    - 支持 solo/kafka/sBFT 等不同的 ordering 策略
- committer
    - 将 chaincode 执行结果写进 ledger
- Peer: Commits transactions, maintains ledger and state
- Endorsing peer: Specialised peer that receives a transaction proposal for endorsement, responds granting or denying endorsement
- Ordering peer: Approves the inclusion of transaction blocks into the ledger and communicates with peer and endorsing peer nodes
- An endorsement policy describes the conditions by which a transacUon can be endorsed
    - A transaction can only be considered valid if it has been endorsed according to the policy
- Nodes send/receive messages to the ordering-service via channels
- The ordering service packages transacUons into blocks to be delivered to peers
    - Communication with the service is via channels
- 数字证书是“公钥+证书名称信息+签发机构对证书的数字签名”、匹配的私钥
- 认证中心 CA（certificate authority）
    - 一个可信的 CA 给每个用户分配一个唯一的名称并签发一个包含用户名称和公钥的证书
- 事务（交易）数据
    – 每个区块中包含一系列的事务数据
    – 事务中包含事务发起方的数字签名（TCert – 交易证书）
    – 每个 Block 中包含所有事务的 Hash, 用于共识时检查事务信息是否与其它节点一致
    – 每个 Block 中包含 World State 的 Hash, 用于共识时检查 State 信息是否与其它节点一致
# src
- Transaction lifecycle and interaction with ledgers，区块链第五讲 P8
# 简介
- 区块链网络的核心是分布式账本，记录网络中发生的所有交易信息
    - 信息以“附加”的方式记录在区块链中
    - 加密技术保障了交易一旦被加入账本就无法篡改
    - 共享的、通过智能合约更新的多副本交易系统
- 区块链网络引入智能合约来实现对账本的访问和控制
- 区块链网络中账本信息和更新账本的程序都是共享的
- **共识**
    - 保持网络中所有账本交易同步的流程
    - 保证账本只会在交易双方都确认后才进行更新
    - 账本更新时，交易双方能够在账本中的相同位置，更新一个相同的交易信息
- Hyperledger Fabric 与其它区块链系统的最大不同体现在**私有**和**许可**，通过 MSP 来登记所有的成员
    - > 开放、无需许可的网络系统允许未知身份的参与者加入网络，需要通过工作量证明来保证交易有效，并维护网络安全
- Fabric 提供多个可插拔选项：账本数据可存储为多个格式；共识机制可被接入或断开；支持多种不同的 MSP
- Fabric 提供**建立 channel** 的功能，允许参与者为**交易新建一个单独的账本**
    - 只有在同一个 channel 中的参与者才会拥有该 channel 中的账本，不在此 channel 中的参与者看不到此账本
- Fabric 包含一个**子账本系统**，子账本包含世界状态和交易记录两个组件
    - 网络中的每一个参与者都拥有一个该账本的副本
    - 世界状态组件描述了账本在特定时间点的状态，是账本的数据库
    - 交易记录组件记录了产生世界状态当前值的所有交易，是世界状态的更新历史
    - 世界状态的存储数据库可更换，默认配置下这是一个 key-value 存储数据库
    - 交易记录模块不需要被接入，只需要记录区块链网络中账本数据库被使用之前和之后的值
- **Fabric 智能合约被称为 chaincode**
    - 区块链外部的一个应用程序要访问账本时，就会调用 chaincode
    - 多数情况下，chaincode 只会访问账本的数据库组件和世界状态，而不会查询交易记录
    - 目前 chaincode 用 Go 实现
- **共识**
    - 网络中，不同的参与者写入的交易必须按照产生顺序依次被写入账本中；要实现这一目标，交易顺序必须被正确的建立，并且必须包含拒绝误（或是恶意）插入无效交易的方法
    - Fabric 共识机制包括 SOLO，Kafaka，SBFT（Simplified Byzantine Fault Tolerance）
    - > PBFT（Practical Byzantine Fault Tolerance）为文件副本提供一种相互通信的机制，即使在发生腐败的情况下，也能保证每个副本保持一致
    - > 比特币中，通过一种称为挖矿的行为进行排序。挖矿过程中，竞争的计算机竞相解决一个密码难题，谜题定义了所有后续的构建顺序